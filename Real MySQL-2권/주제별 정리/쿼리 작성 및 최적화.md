# 쿼리 작성 및 최적화

### 숫자
숫자 값을 상수로 SQL 에 사용할 때는 다른 DBMS 와 마찬가지로 따옴표 또는 없이 숫자 값을 입력하면 된다.  
비교 대상이 숫자 값이거나 숫자 타입의 컬럼이면 MySQL 서버가 문자열 값을 숫자 값으로 자동 변환한다.
```sql
SELECT * FROM TAB_TEST WHERE number_column='10001'; 
SELECT * FROM TAB_TEST WHERE string_column=10001; --성능 문제 발생
```
> MySQL 은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환 후 비교


### 날짜
다른 DBMS에서 날짜 타입을 비교하거나 INSERT 하려면 문자열을 DATE 타입으로 변환하는 코드가 필요  
MySQL 에서는 서버가 자동으로 DATE나 DATETIME 값으로 변환
```sql
select * from dept_emp where from_date='2011-04-29';
select * from dept_emp where from_date=STR_TO_DATE('2011-04-29', '%Y-%m-%d');
```

### 동등 비교
`<=>`연산자는 NULL 값에 대한 비교까지 수행한다. MySQL 에서는 이 연산자를 `NULL-Safe` 비교 연산자라고 함

### 부정 비교
`<>`, 와 `!=` 어느쪽을 사용하든 특별히 문제가 되지는 않겠지만 통일해서 사용하는 방법을 권장

### REGEXP 연산자
정규표현식을 사용하여 검색하며, 인덱스 레인지 스캔을 사용할 수 없기 때문에 가능하다면 데이터 조회 범위를 줄일 수 있는 조건과 함께 사용하길 권장

### 현재시각 조회 (NOW, SYSDATE)
하나의 SQL 에서 모든 `NOW()` 함수는 같은 값을 가지지만 `SYSDATE()` 함수는 하나의 SQL 내에서도 호출되는 시점에 따라 결괏값이 달라진다.  
`NOW()`의 경우 쿼리가 1시간 동안 실행되더라도 실행되는 위치나 시점에 관계없이 항상 같은 값을 보장 할 수 있다.

 > 꼭 필요한 때가 아니라면 SYSDATE() 함수를 사용하지 않는 편이 좋다.

### JSON_EXTRACT()
MySQL 서버는 다음과 같이 JSON 연산자를 제공한다
```sql
SELECT EMP_NO, DOC->"$.first_name" FROM employee_docs;
```

### 쿼리 절의 실행 순서
`WHERE 절 적용 및 JOIN 실행` -> `GROUP BY` -> `DISTINCT` -> `HAVING` -> `ORDER BY` -> `LIMIT`

### WHERE 조건의 인덱스 사용 
WHERE 절의 조건절은 순서를 변경해도 결과의 차이가 없기 때문에 WHERE 절에서의 각 조건이 명시된 수서는 중요치 않고 인덱스를 구성하는 컬럼의 대한 조건이 있는지 없는지가 중요하다.

### GROUP BY 절의 인덱스 사용
GROUP BY 절의 인덱스 조건은 WHERE 조건절과는 달리 GROUP BY 절에 명시된 컬럼이 하나라도 인덱스에 없으면 GROUP BY 절은 전혀 인덱스를 이용하지 못한다.
> 하지만 선행 인덱스가 동등 비교 조건으로 사용된다면 인덱스 이용할 수 있음

```sql
...WHERE COL_1='상수' AND COL_2='상수' ...GROUP BY COL_3, COL_4
```

### ORDER BY 절의 인덱스 사용
GROUP BY 의 요건과 거의 흡사하다. 다만 정렬되는 각 컬럼의 오름차순 및 내림차순 옵션이 인덱스와 같거나 정반대인 경우에만 사용할 수 있다.

### GROUP BY 절과 ORDER BY 절의 인덱스 사용
GROUP BY 절과 ORDER BY 절이 동시에 사용된 쿼리에서 두 절이 모두 하나의 인덱스를 사용해서 처리되려면 GROUP BY 절에 명시된 컬럼과 ORDER BY에 명시된 컬럼의 순서와 내용이 모두 같아야 한다.  
같이 사용된 쿼리에서는 둘 중 하나라도 인덱스를 이용할 수 없을 때는 둘 다 인덱스를 사용하지 못한다.

### WITH ROLLUP
`WITH ROLLUP` 과 함께 사용된 GROUP BY 쿼리의 결과는 그룹별로 소계를 출력하는 레코드가 추가되어 표시된다.

```sql
SELECT DEPT_NO, COUNT(*) 
  FROM DEPT_EMP
 GROUP BY DEPT_NO WITH ROLLUP;
```
마지막 소계의 DEPT_NO 컬럼값은 NULL로 표기된다.

### CTE
```sql
WITH CTE1 AS (SELECT * FROM DEPARTMENTS)
SELECT * FROM CTE1;
```
 - CTE 임시 테이블은 재사용 가능하므로 FROM 절의 서브쿼리보다 효율적이다.
 - CTE로 선언된 임시 테이블을 다른 CTE 쿼리에서 참조할 수 있다.
 - CTE는 임시 테이블의 생성 부분과 사용 부분의 코드를 분리할 수 있으므로 가독성이 높다.

### 재귀적 CTE
```sql
WITH RECURSIVE CTE (NO) AS (
    SELECT 1
    UNION ALL
    SELECT (NO + 1) FROM CTE WHERE NO < 5
)
SELECT * FROM CTE;
```



