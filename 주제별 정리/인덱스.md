# 인덱스

## 구조 및 특성
`InnoDB`테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.
이는 `오라클`의 IOT 나 `MS-SQL`의 클러스터 테이블과 같은 구조를 말한다.
`클러스터링`이란 비슷한 값을 최대한 모아서 저장하는 방식을 의미

## B-Tree

---
### 인덱스 키 추가
리프 노드가 꽉 차서 더는 저장할 수 없을 때는 `리프 노드`가 분리돼야 하는데, 이는 상위 `브랜치 노드`까지 처리의 범위가 넓어진다.
이러한 작업 탓에 `B-Tree`는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 드는 것으로 알려졌다.

### 인덱스 키 검색
`B-Tree` 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다. 부등호 `<`, `>` 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구상하는 키값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.

또한 인덱스를 이용한 검색에서 중요한 사실은 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 절대 `B-Tree`의 빠른 검색 기능을 사용할 수없다는 것이다.

> `UPDATE`나 `DELETE` 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.  
> `InnoDB`스토리지 엔진에서는 그만큼 인덱스의 설계가 중요하고 많은 부분에 영향을 미친다.

### 선택도(기수성)
모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다. 전체 인덱스 키 값은 100개인데, 그중에서 유니크한 값의 수는 10개라면 기수성은 10이다.
인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
> 선택도가 좋지 않다고 하더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 많다.  
> 인덱스가 항상 검색에만 사용되는 것은 아니므로 여러 가지 용도를 고려해 적절히 인덱스를 설계할 필요가 있다.

### 인덱스 레인지 스캔

인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.  
이때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한번씩 일어난다.  
인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리 방식이 된다.

### 인덱스 풀스캔
인덱스 (`A`, `B`, `C`) 칼럼의 순서로 만들어져 있지만 쿼리의 조건절은 `B`칼럼이나 `C`칼럼으로 검색하는 경우.  
인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 후, 인덱스의 리프 노드를 연결하는 링크드 리스트를 따라서 처음부터 끝까지 스캔하는 방식.  
이 방식은 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다. 단, 모든컬럼을 가져와야 하는경우는 풀스캔이다.


