# 실행계획

### 히스토그램
MySQL5.7 버전까지의 통계 정보는 단순히 인덱스된 컬럼의 유니크한 값의 개수 정도만 가지고 있었다.  
옵티마이저는 이러한 부족함을 메우기 위해 실행계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용.  
`8.0`버전으로 업그레이드되면서 드디어 컬럼의 데이터 분포도를 참조할 수 있는 `히스토그램` 정보를 활요할 수 있게 됐다.

### 히스토그램 용도
기존 MySQL 서버가 가지고 있던 통계 정보는 테이블의 전체 레코드 건수와 인덱스된 컬럼이 가지는 유니크한 값의 개수 정도였다.  
실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않는다.  
이러한 단점을 보완하기 위해 히스토그램이 도입됐으며, 히스토그램은 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있음

### 실행계획
`EXPLAIN ANALYZE`명령은 `EXPLAIN`명령과 달리 실행 계획만 추출하는 것이 아니라 실제 쿠러리르 실행하고 사용된 실행 계획과 소요된 시간을 보여주는 것이다.  
쿼리의 실행 계획이 아주 나쁜 경우라면 EXPLAIN 명령으로 먼저 실행 계획만 확인해서 어느 정도 튜닝한 후 EXPLAIN ANALYZE 명령을 실행하는 것이 좋다.

### SUBQUERY
> 서브쿼리는 사용하는 위치에 따라 각각 다른 이름을 지니고 있다.  
> - 중첩된 쿼리`Nested Query` : SELECT 되는 컬럼에 사용된 서브쿼리를 네스티드 쿼리라고 한다.  
> - 서브쿼리`Subquery` : WHERE 절에 사용된 경우에는 일반적으로 그냥 서브쿼리라고 한다.  
> - 파생 테이블`Drived Table` : FROM 절에 사용된 서브쿼리를 MySQL 에서는 파생 테이블이라고 하며, 일반적으로 RDBMS 에서는 인라인 뷰`Inline View` 또는 서브 셀렉트`Sub Select`라고 부른다.
 
쿼리를 서브쿼리 형태로 작성하는 것이 편하다면 반드시 마지막에는 서브쿼리를 조인으로 풀어서 고쳐 쓰는 습관을 들이자. 그러면 어느 순간 서브쿼리로 작성하는 단계 없이
바로 조인으로 복잡한 쿼리를 개발할 수 있을 것이다.
 - 서브쿼리는 조인쿼리에 비해 생산성은 높을 수 있겠지만 `쿼리의 성능은 떨어진다.`