# 인덱스

## 구조 및 특성
`InnoDB`테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.
이는 `오라클`의 IOT 나 `MS-SQL`의 클러스터 테이블과 같은 구조를 말한다.
`클러스터링`이란 비슷한 값을 최대한 모아서 저장하는 방식을 의미

## B-Tree

---
### 인덱스 키 추가
리프 노드가 꽉 차서 더는 저장할 수 없을 때는 `리프 노드`가 분리돼야 하는데, 이는 상위 `브랜치 노드`까지 처리의 범위가 넓어진다.
이러한 작업 탓에 `B-Tree`는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 드는 것으로 알려졌다.

### 인덱스 키 검색
`B-Tree` 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다. 부등호 `<`, `>` 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구상하는 키값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.

또한 인덱스를 이용한 검색에서 중요한 사실은 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 절대 `B-Tree`의 빠른 검색 기능을 사용할 수없다는 것이다.

> `UPDATE`나 `DELETE` 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.  
> `InnoDB`스토리지 엔진에서는 그만큼 인덱스의 설계가 중요하고 많은 부분에 영향을 미친다.

### 선택도(기수성)
모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다. 전체 인덱스 키 값은 100개인데, 그중에서 유니크한 값의 수는 10개라면 기수성은 10이다.
인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
> 선택도가 좋지 않다고 하더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 많다.  
> 인덱스가 항상 검색에만 사용되는 것은 아니므로 여러 가지 용도를 고려해 적절히 인덱스를 설계할 필요가 있다.

### 인덱스 레인지 스캔

인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.  
이때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한번씩 일어난다.  
인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리 방식이 된다.

### 인덱스 풀스캔
인덱스 (`A`, `B`, `C`) 칼럼의 순서로 만들어져 있지만 쿼리의 조건절은 `B`칼럼이나 `C`칼럼으로 검색하는 경우.  
인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 후, 인덱스의 리프 노드를 연결하는 링크드 리스트를 따라서 처음부터 끝까지 스캔하는 방식.  
이 방식은 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다. 단, 모든컬럼을 가져와야 하는경우는 풀스캔이다.

### 클러스터링 인덱스
클러스터링이란 여러 개를 하나로 묶는다는 의미로 주로 사용된다.
MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한것들 끼리 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안.
MySQL 에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원하며, 나머지 스토리지 엔진에서는 지원되지 않는다.

> 클러스터링 인덱스는 테이블의 `프라이머리 키`에 대해서만 적용되는 내용이다.  
> 프라이머리 키 값으로 클러스터링된 테이블은 프라이머리 키 값 자체에 대한 의존도가 상당히 크기 때문에 신중히 프라이머리 키를 결정해야 한다.

인덱스 알고리즘이라기보다 테이블 레코드의 저장 방식이라고 볼 수 있다.  
일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다.

#### 장단점

|    | 특징                                                                                                                                                                                                                            |
|----|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 장점 | - 프라이머리 키로 검색할 때 처리 성능이 매우 빠름<br/> - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우 많다.                                                                                                                             |
| 단점 | - 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐<br/>- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림<br/>- INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림<br/>- 프라이머리 키를 변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리 성능이 느림 |

> 프라이머리 키는 `AUTO-INCREMENT`보다는 업무적인 칼럼으로 생성 ( 가능한 경우 )


